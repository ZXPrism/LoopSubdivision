## LoopSubdivision

### 原理简述
记 $\mathbb{E}$ 为**原来的边**的集合，$\mathbb{V}$ 为**原来的点**的集合。

- 对于边 $e\in{}\mathbb{E}$，计算出新增边点，并维护字典 `adjVertMap` ，其中，键为**原来的点**，值为链表，用来存放与**原来的点**相邻的新增边点。利用数组 `edgeVert` 来标记每条边对应的新增边点。
    - 情况 1：当前处理的边属于两个不同的面
        $$
        edgeVert=\frac{1}{8}(V_0+V_2)+\frac{3}{8}(V_1+V_3)
        $$
    - 情况 2：当前处理的边仅属于一个面（暂未实现，因此也并不支持读入存在这种边的模型）
        $$
        edgeVert=\frac{1}{2}(V_1+V_3)
        $$

    > 要点在于，如何**快速**得到**与某条边相关联的面及相应的顶点**。

- 更新原有点的位置：
  $$
  O'=(1-n\beta{})\cdot{}O+\beta{}\sum\limits_{i=0}^{n-1}V_i
  $$
  其中，
  $$
  \beta{}=\frac{1}{n}[\frac{5}{8}-(\frac{3}{8}+\frac{1}{4}\cos{\frac{2\pi{}}{n}})^2]
  $$

- 更新边集和点集。单纯地把每三个新增点两两连接虽然也可以，但不利于算法的重复执行，因为这样做丢失了面的信息。我们希望的是，在执行算法的全流程之后，依然保持其原先的性质。
